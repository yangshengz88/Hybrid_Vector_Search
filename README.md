# Hybrid Vector Search for Music Retrieval  
This repository implements a hybrid search system for music retrieval that combines **vector similarity search** using FAISS with **structured metadata filtering** (year, key, tempo, explicit, etc.). The system evaluates multiple search strategies including pre-filtering, post-filtering, and our optimized predicate-pushdown hybrid method.

---

## Project Overview  
Hybrid search queries must satisfy both **semantic similarity** (via vector embeddings) and **metadata constraints**. Traditional pipelines rely on:

- **Pre-filtering**: filter -> exact NN search  
- **Post-filtering**: search -> filter -> rerank  

These approaches struggle with either high latency (pre-filter) or recall loss (post-filter).  
Our project addresses these limitations through **predicate pushdown over IVF-Flat**, skipping irrelevant FAISS clusters before vector scoring.

---

## Main Contributions  
- Construction of a 14-dimensional audio+metadata embedding  
- Efficient metadata indexing using inverted lists and sorted range indexes  
- FAISS IndexFlatL2 and IVF-Flat index construction  
- A hybrid predicate-pushdown search that prunes clusters early  
- Complete evaluation pipeline with baselines and hybrid experiments  
- Modular, reproducible implementation in separate notebooks  

---

## Experimental Setup  

**Hardware:** CPU (FAISS CPU index)  
**Software:** Python, FAISS, NumPy, Pandas, scikit-learn, Matplotlib  
**Dataset:** 169,776 tracks  
**Embedding dimension:** 14  
**Indexes:** IndexFlatL2 (exact), IVF-Flat (ANN)  
**Query workload:** 100 mixed metadata queries  


## Mapping Code and Data to Report Sections  

### **Section 2.1.1**- FAISS Indexing Layer and Metadata Indexing Layer
- `FAISS_Index_Construction.ipynb`  
- `Metadata_Indexing.ipynb`
- `data/index_config.json` (Output generated by the FAISS Indexing Code)
- `data/categorical_indexes.json (Output generated by the Metadata Indexing Code)
- `data/numeric_indexes.json (Output generated by the Metadata Indexing Code)
- `data/metadata_filter.pkl  (Output generated by the Metadata Indexing Code)

### **Section 2.1.2, 2.2**- Hybrid Search Execution
- `Hybrid_Method.ipynb` 
- `data/index_ivf_flat.faiss` (Output generated by the Hybrid Method)
- `data/index_flat_l2.faiss` (Output generated by the Hybrid Method)
  
### **Section 3.1**- Dataset Characteristics, Generate Embeddings and Query Workload
- `Spotify_Dataset_EDA.ipynb` 
- `Query_workload.ipynb`
- `Generate_Embeddings.ipynb`
- `data/query_workload.json` (Output generated by the Dataset EDA)
- `data/spotify_vectors_14d.npy` (Output generated by the Embedding Code)
- `data/id_to_index.json` (Output generated by the Embedding Code)
- `data/query_workload.json` (Output generated by the Query Workload Code)

 ### **Section 3.3**- Baseline Implementation
- `Baseline_tests.ipynb` 

### **Section 4**- Evaluation and Plots
- `Baseline_tests.ipynb`
- `Hybrid_Method.ipynb`
---


## Dataset Characteristics  
We used the Spotify Tracks dataset containing **170,653 tracks (19 features)**. After removing outliers in tempo and duration, our cleaned dataset contains **169,776 tracks** with:

- **Numeric features**: danceability, energy, valence, tempo, acousticness, instrumentalness, liveness, speechiness, loudness, popularity  
- **Categorical metadata**: key, mode, explicit, artists  
- **Numeric metadata**: year, duration_ms  

### Embedding Construction  
We create a **14-dimensional embedding** built from:
- Standardized audio features  
- Weighted scaling to reflect musical similarity  
- Encoded categorical features (key, mode, explicit)  
- Scaled year  

This compact representation is optimized for FAISS vector search while preserving metadata semantics.

---

## Baseline Search Methods  

### **Pre-Filter Baseline** - Filter -> Exact Search  
- Apply metadata filters directly to the dataset  
- Perform exact L2 search over the filtered subset  
- High recall as long as >= K items survive  
- Serves as the conceptual ground truth

### **Post-Filter Baseline** - Exact Search -> Filter -> Rerank  
- Retrieve a large unfiltered pool (pool_size = 500)  
- Apply metadata filters  
- Recompute exact distances and rerank  
- Faster but may lose recall for selective queries
- Although our hybrid system uses nprobe-based ANN traversal, we intentionally retain the pool_size-based baseline so both approaches can be evaluated side-by-side.  

---

## Hybrid Predicate - Pushdown Search  
The hybrid method incorporates metadata filtering into the IVF-Flat traversal:

1. Precompute metadata bitmaps for cluster contents  
2. Skip clusters that contain no valid tracks  
3. Perform local vector search only within valid clusters  
4. Merge and rerank candidates  

This reduces unnecessary FAISS computations while maintaining accuracy.

---







